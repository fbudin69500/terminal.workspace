# Configure environment per workspace

# The configuration is defined in a file called .workspace.config
# that is contained in any folder. If such a file is found
# in the current folder or any of its parents, this file
# is sourced.

# Functions defined in module files contained in the subdirectory
# called "modules" are used to activate and deactivate the current
# workspace.

# `${module}_activate_workspace and `${module}_deactivate_workspace`
# can be defined to run actions that are executed when a workspace
# is activated (entering) or deactivated (leaving).

# Search for project config file in current directory and
# recursively in parent directories until root directory is found.


# WORKSPACE_FILENAME environment variable is set and unset during the
# set up process of this script. It is used inside the module files
# to select whether or not the activation and deactivation process
# happen in the default WORKSPACE folder or in a different folder.

# Use `WORKSPACE_CONFIG_LOOK_UP` environment variable to avoid
# calling the function recursively when changing folder inside
# the folder configuration file.

DEFAULT_WORKSPACE_FILENAME=.workspace.config

function _function_lock {
    export WORKSPACE_CONFIG_LOOK_UP=1
    $@
    unset WORKSPACE_CONFIG_LOOK_UP
}

# Deactivate workspace
# Deactivate virtual environment, unload packages, remove
# environment variables.
function _deactivate_workspace {
    if [[ -n "$1" ]] && [[ -f "$1/$config_filename" ]]; then
        for func in ${_deactivate_fcts[@]}
        do
            if [[ -n "$DEBUG_WORKSPACE" ]]; then
                echo "deactivate: $func $1/$config_filename"
            fi
            $func "$1/$config_filename"
        done
        if [[ -n "$DEBUG_WORKSPACE" ]]; then
            echo "unset ${CURRENT_VARIABLE}"
        fi
        unset ${CURRENT_VARIABLE}
    fi
}

# Manually deactivate a workspace
#function deactivate_workspace {
#    local current_path=$1
#    _function_lock _deactivate_workspace
#}

# Activate workspace
# Activate virtual environment, load packages.
function _activate_workspace {
    export $CURRENT_VARIABLE=$current_path
    for func in ${_activate_fcts[@]}
    do
        if [[ -n "$DEBUG_WORKSPACE" ]]; then
            echo "$func $current_path/$config_filename"
        fi
        $func "$current_path/$config_filename"
    done
}

# Returns 0 if workspace is activated and print workspace
# name if verbose.
#function is_workspace_on {
#    if [[ $# -gt 1 ]] || [[ $# -eq 1 ]] && [[ $1 != "-v" ]]; then
#        # $funcstack[1] is used in zsh
#        # ${FUNCNAME[0]} is used in bash
#        echo "Usage: ${FUNCNAME[0]}$funcstack[1] [-v]"
#    fi
#    local _current=${!CURRENT_VARIABLE}
#    local ret=0
#    if [[ -z "${!CURRENT_VARIABLE}" ]]; then
#        local _current="None"
#        local ret=1
#    fi
#    if [[ $1 == "-v" ]]; then
#        echo "Current workspace: $_current"
#    fi
#    return $ret
#}

# Manually activate a workspace
#function activate_workspace {
#    config_filename="$DEFAULT_WORKSPACE_FILENAME"
#    if [[ $# -ne 1 ]] || [[ ! -f $1/$config_filename ]]; then
#        echo "Function requires one argument: valid workspace directory"
#        return 1
#    fi
#    local current_path=$1
#    # First deactivate previous workspace
#    _function_lock _deactivate_workspace
#    # Then activate new workspace
#    _function_lock _activate_workspace
#}

# Function looking up file in parent directory
function _workspace_hook {
    local config_filename="${WORKSPACE_FILENAME_LIST[$1]}"
    # for zsh, to be able to split strings the same way as in bash
    if [ -n "$ZSH_VERSION" ]; then
        setopt localoptions sh_word_split
    fi
    local _activate_fcts=("${WORKSPACE_ACTIVATE_FUNCTIONS[$1]}")
    local _deactivate_fcts=("${WORKSPACE_DEACTIVATE_FUNCTIONS[$1]}")
    local CURRENT_VARIABLE=CURRENT_${1}
    if [[ -n "$DEBUG_WORKSPACE" ]]; then
        echo "key: $1"
        echo "config_filename:$config_filename"
        echo "_activate_fcts:$_activate_fcts"
        echo "_deactivate_fcts:$_deactivate_fcts"
        echo "CURRENT_VARIABLE:$CURRENT_VARIABLE"
    fi
    local old_path=""
    if [[ -n $(env |grep $CURRENT_VARIABLE) ]]; then
        if [ -n "$ZSH_VERSION" ]; then
           # assume Zsh
            old_path=${(P)CURRENT_VARIABLE}
        else
            old_path=${!CURRENT_VARIABLE}
        fi
    fi
    local current_path=`pwd`
    while [[ $current_path != / ]];
    do
        res=`find "$current_path" -maxdepth 1 -mindepth 1 -name $config_filename`
        if [[ -f $res ]]
        then
            if [[ -n "$DEBUG_WORKSPACE" ]]; then
                echo "Current workspace: $res"
            fi
            # If same workspace as before, do nothing to save time
            if [[ `dirname $res` == "$old_path" ]]; then
                return 0
            fi
            # First deactivate previous workspace
            _function_lock _deactivate_workspace "$old_path"
            # Then activate new workspace
            _function_lock _activate_workspace
            return 0
        fi
        current_path="$(readlink -f "$current_path"/..)"
    done
    _function_lock _deactivate_workspace "$old_path"
}

# Get attribute array keys either in bash or in zsh.
# Note: Bash is assumed if zsh is not detected.
# Parameters:
# * $1: attribute array
# * $2: return variable name
function _get_array_keys {

}

# Function called when one changes folder.
function chpwd {
    if [[ -n $WORKSPACE_CONFIG_LOOK_UP ]]; then
        return 0
    fi
    for key in ${WORKSPACE_NAME_LIST[@]}
    do
        _workspace_hook $key
    done
    # Make sure that `WORKSPACE_CONFIG_LOOK_UP` is cleaned up.
    # Potentially can be removed
    unset WORKSPACE_CONFIG_LOOK_UP
}

function _add_function_to_list {
  # Check if functions exist and add them to list of available functions
  function_name=${1}_${2}_workspace
  # Execute function to verify that it exists. Redirects outputs
  # to allow functions to print statements without messing the result
  # of this function that is printed on screen to be passed
  # back to its caller.
  $(type -f $function_name  > /dev/null 2>&1)
  if [[ $? == 0 ]]; then
    echo $function_name
  fi
}

# Get this script directory
if [ -n "$ZSH_VERSION" ]; then
   # assume Zsh
    DIR="$(dirname ${(%):-%N})"
else
   # assume Bash
   # Do not check "$BASH_VERSION"
   DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null && pwd)"
fi

WORKSPACE_MODULE_DIRECTORY=$DIR/modules

# Load all modules

# Declare global variables
declare -A WORKSPACE_ACTIVATE_FUNCTIONS
declare -A WORKSPACE_DEACTIVATE_FUNCTIONS
declare -A WORKSPACE_FILENAME_LIST

if [ ! -d "$WORKSPACE_MODULE_DIRECTORY" ] || [ -z "$(ls -A $WORKSPACE_MODULE_DIRECTORY)" ]
then
  echo "No workspace module directory found or empty."
  return
fi

for name in $(find $WORKSPACE_MODULE_DIRECTORY/* -type f | sort -z | tr -d '\00');
do
  # Get module name
  source $name
  module=$(echo $name | sed -n 's;[^-]*-\(.*\);\1;p')
  if [[ -z "$WORKSPACE_FILENAME" ]]; then
    # Set default values
    WORKSPACE_NAME=workspace
    WORKSPACE_FILENAME_LIST[$WORKSPACE_NAME]="$DEFAULT_WORKSPACE_FILENAME"
  else
    WORKSPACE_NAME=$module
    WORKSPACE_FILENAME_LIST[$WORKSPACE_NAME]="$WORKSPACE_FILENAME"
  fi
  WORKSPACE_ACTIVATE_FUNCTIONS[$WORKSPACE_NAME]+=" "$(_add_function_to_list $module activate)
  WORKSPACE_DEACTIVATE_FUNCTIONS[$WORKSPACE_NAME]+=" "$(_add_function_to_list $module deactivate)
  # Need to unset `WORKSPACE_FILENAME` so that modules that do not declare it
  # use default workspace name.
  unset WORKSPACE_FILENAME
done

# Get workspace names. We do it once the array is created as the attribute array
# takes care of the uniqueness of the keys when the array is created.
# In theory we could skip that test and loop over the keys, but it is difficult
# to extract them both in zsh and bash, and inside a function, so we preemptively
# do it early.
if [ -n "$ZSH_VERSION" ]; then
    # assume Zsh
    for key val in ${(kv)WORKSPACE_FILENAME_LIST}; do
        WORKSPACE_NAME_LIST+=("$key")
    done
    eval $1=$keys
else
    # assume Bash
    # Do not check "$BASH_VERSION"
    WORKSPACE_NAME_LIST=${!WORKSPACE_FILENAME_LIST[@]}
fi

# Debug info.
if [[ -n "$DEBUG_WORKSPACE" ]]; then
    echo "WORKSPACE_NAME_LIST:${WORKSPACE_NAME_LIST}"
    for key val in ${(kv)WORKSPACE_FILENAME_LIST}; do
        echo "$key ->$val"
    done
    # bash
    # echo "${!WORKSPACE_FILENAME_LIST[@]}"
    echo "${WORKSPACE_FILENAME_LIST[@]}"
    # List keys
    echo "${WORKSPACE_ACTIVATE_FUNCTIONS[@]}"
    echo "workspace activate: ${WORKSPACE_ACTIVATE_FUNCTIONS[workspace]}"
    echo "workspace deactivate: ${WORKSPACE_DEACTIVATE_FUNCTIONS[workspace]}"
fi
# Force call chpwd when sourcing this file.
chpwd
